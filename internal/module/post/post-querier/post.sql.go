// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: post.sql

package postQuerier

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createOne = `-- name: CreateOne :one
INSERT INTO posts (title, slug, category, status, content, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
RETURNING id, title, slug, category, status, content, created_at, updated_at
`

type CreateOneParams struct {
	Title    string
	Slug     string
	Category uuid.UUID
	Status   string
	Content  sql.NullString
}

func (q *Queries) CreateOne(ctx context.Context, arg CreateOneParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createOne,
		arg.Title,
		arg.Slug,
		arg.Category,
		arg.Status,
		arg.Content,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Category,
		&i.Status,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOne = `-- name: DeleteOne :exec
DELETE FROM posts
WHERE id = $1
`

func (q *Queries) DeleteOne(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOne, id)
	return err
}

const getMany = `-- name: GetMany :many
SELECT id, title, slug, category, status, content, created_at, updated_at
FROM posts
WHERE
  (
    ($1::text IS NOT NULL AND title = $1)
    OR
    ($2::text IS NOT NULL AND title ~* $2::text)
    OR
    ($1::text IS NULL AND $2 IS NULL)
  )
  AND
  (
    ($3::text IS NOT NULL AND slug = $3)
    OR
    ($4::text IS NOT NULL AND slug ~* $4::text)
    OR
    ($3::text IS NULL AND $4 IS NULL)
  )
  AND
  (
    ($5::uuid IS NOT NULL AND category = $5)    
    OR
    ($6::uuid[] IS NOT NULL AND category = ANY($6::uuid[]))
    OR
    ($5::text IS NULL AND $6 IS NULL)
  )
  AND
  (
    status = $7 OR $7 IS NULL
  )
ORDER BY
  CASE WHEN $8::text = 'title__asc' THEN title END ASC,
  CASE WHEN $8::text = 'title__desc' THEN title END DESC,
  CASE WHEN $8::text = 'created_at__asc' THEN created_at END ASC,
  CASE WHEN $8::text = 'created_at__desc' THEN created_at END DESC,
  CASE WHEN $8::text = 'updated_at__asc' THEN updated_at END ASC,
  CASE WHEN $8::text = 'updated_at__desc' THEN updated_at END DESC,
  CASE WHEN $8::text = 'status__asc' THEN status END ASC,
  CASE WHEN $8::text = 'status__desc' THEN status END DESC
LIMIT $10 OFFSET $9
`

type GetManyParams struct {
	TitleEq    sql.NullString
	TitleRegex sql.NullString
	SlugEq     sql.NullString
	SlugRegex  sql.NullString
	CategoryEq uuid.NullUUID
	CategoryIn []uuid.UUID
	Status     sql.NullString
	SortQuery  sql.NullString
	Offset     sql.NullInt32
	Limit      sql.NullInt32
}

func (q *Queries) GetMany(ctx context.Context, arg GetManyParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getMany,
		arg.TitleEq,
		arg.TitleRegex,
		arg.SlugEq,
		arg.SlugRegex,
		arg.CategoryEq,
		pq.Array(arg.CategoryIn),
		arg.Status,
		arg.SortQuery,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Category,
			&i.Status,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyByIds = `-- name: GetManyByIds :many
SELECT id, title, slug, category, status, content, created_at, updated_at FROM posts
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetManyByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getManyByIds, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Category,
			&i.Status,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneById = `-- name: GetOneById :one
SELECT id, title, slug, category, status, content, created_at, updated_at FROM posts
WHERE id = $1
`

func (q *Queries) GetOneById(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getOneById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Category,
		&i.Status,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOneById = `-- name: UpdateOneById :one
UPDATE posts SET
  title = coalesce($1, title),
  slug = coalesce($2, slug),
  category = coalesce($3, category),
  status = coalesce($4, status),
  content = coalesce($5, content),
  updated_at = now()
WHERE id = $6 RETURNING id, title, slug, category, status, content, created_at, updated_at
`

type UpdateOneByIdParams struct {
	Title    sql.NullString
	Slug     sql.NullString
	Category uuid.NullUUID
	Status   sql.NullString
	Content  sql.NullString
	ID       uuid.UUID
}

func (q *Queries) UpdateOneById(ctx context.Context, arg UpdateOneByIdParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updateOneById,
		arg.Title,
		arg.Slug,
		arg.Category,
		arg.Status,
		arg.Content,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Category,
		&i.Status,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
